const express = require("express");
const { Client } = require("pg");
const { spawn, execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

const app = express();
const MANAGEMENT_PORT = 3000;

if (!process.env.POSTGRES_USER) {
  console.warn("WARNING: POSTGRES_USER not set, using default 'postgres' (for testing only)");
  process.env.POSTGRES_USER = 'postgres';
}
if (!process.env.POSTGRES_PASSWORD) {
  console.warn("WARNING: POSTGRES_PASSWORD not set, using default 'postgres' (for testing only)");
  process.env.POSTGRES_PASSWORD = 'postgres';
}
if (!process.env.POSTGRES_DB) {
  console.warn("WARNING: POSTGRES_DB not set, using default 'postgres' (for testing only)");
  process.env.POSTGRES_DB = 'postgres';
}

// Replication configuration
const REPLICATION_MODE = process.env.POSTGRES_REPLICATION_MODE || 'standalone'; // standalone, primary, replica
const REPLICATION_USER = process.env.POSTGRES_REPLICATION_USER || 'replicator';
const REPLICATION_PASSWORD = process.env.POSTGRES_REPLICATION_PASSWORD || '';
const PRIMARY_HOST = process.env.POSTGRES_PRIMARY_HOST || '';
const PRIMARY_PORT = parseInt(process.env.POSTGRES_PRIMARY_PORT || '5432', 10);
const REPLICATION_SLOT_NAME = process.env.POSTGRES_REPLICATION_SLOT_NAME || 'replica_slot';
const WAL_LEVEL = process.env.POSTGRES_WAL_LEVEL || 'replica';
const MAX_WAL_SENDERS = parseInt(process.env.POSTGRES_MAX_WAL_SENDERS || '10', 10);
const MAX_REPLICATION_SLOTS = parseInt(process.env.POSTGRES_MAX_REPLICATION_SLOTS || '10', 10);
const WAL_KEEP_SIZE = process.env.POSTGRES_WAL_KEEP_SIZE || '1GB';
const HOT_STANDBY = process.env.POSTGRES_HOT_STANDBY || 'on';
const HOT_STANDBY_FEEDBACK = process.env.POSTGRES_HOT_STANDBY_FEEDBACK || 'on';
const SYNCHRONOUS_COMMIT = process.env.POSTGRES_SYNCHRONOUS_COMMIT || 'on';
const SYNCHRONOUS_STANDBY_NAMES = process.env.POSTGRES_SYNCHRONOUS_STANDBY_NAMES || '';
const ARCHIVE_MODE = process.env.POSTGRES_ARCHIVE_MODE || 'off';
const ARCHIVE_COMMAND = process.env.POSTGRES_ARCHIVE_COMMAND || '';
const RESTORE_COMMAND = process.env.POSTGRES_RESTORE_COMMAND || '';
const RECOVERY_TARGET_TIMELINE = process.env.POSTGRES_RECOVERY_TARGET_TIMELINE || 'latest';
const PRIMARY_CONNINFO_EXTRA = process.env.POSTGRES_PRIMARY_CONNINFO_EXTRA || '';
const REPLICATION_ALLOWED_NETWORKS = process.env.POSTGRES_REPLICATION_ALLOWED_NETWORKS || '0.0.0.0/0';

const PGDATA = process.env.PGDATA || '/var/lib/postgresql/data';

let postgresProcess = null;
let dbReady = false;
let pgClient = null;
let startupTimingWritten = false;

// Generate PostgreSQL configuration for replication
function generateReplicationConfig() {
  if (REPLICATION_MODE === 'standalone') {
    console.log("Replication mode: standalone - no replication configuration needed");
    return;
  }

  console.log(`Configuring PostgreSQL for replication mode: ${REPLICATION_MODE}`);

  // Generate postgresql.conf additions
  let pgConfig = `
# Replication configuration (generated by OpenRuntimes)
wal_level = ${WAL_LEVEL}
max_wal_senders = ${MAX_WAL_SENDERS}
max_replication_slots = ${MAX_REPLICATION_SLOTS}
wal_keep_size = ${WAL_KEEP_SIZE}
`;

  if (REPLICATION_MODE === 'primary') {
    pgConfig += `
# Primary-specific settings
listen_addresses = '*'
synchronous_commit = ${SYNCHRONOUS_COMMIT}
`;
    if (SYNCHRONOUS_STANDBY_NAMES) {
      pgConfig += `synchronous_standby_names = '${SYNCHRONOUS_STANDBY_NAMES}'\n`;
    }
    if (ARCHIVE_MODE !== 'off') {
      pgConfig += `archive_mode = ${ARCHIVE_MODE}\n`;
      if (ARCHIVE_COMMAND) {
        pgConfig += `archive_command = '${ARCHIVE_COMMAND}'\n`;
      }
    }
  } else if (REPLICATION_MODE === 'replica') {
    pgConfig += `
# Replica-specific settings
hot_standby = ${HOT_STANDBY}
hot_standby_feedback = ${HOT_STANDBY_FEEDBACK}
`;
  }

  // Write to conf.d directory
  const confDir = path.join(PGDATA, 'conf.d');
  const confPath = path.join(confDir, 'replication.conf');

  try {
    if (!fs.existsSync(confDir)) {
      fs.mkdirSync(confDir, { recursive: true });
    }
    fs.writeFileSync(confPath, pgConfig);
    console.log(`Replication configuration written to ${confPath}`);
  } catch (err) {
    console.error(`Failed to write replication config: ${err.message}`);
  }

  // Generate pg_hba.conf entries for replication
  if (REPLICATION_MODE === 'primary') {
    const hbaPath = path.join(PGDATA, 'pg_hba.conf');
    const replicationEntry = `
# Replication entries (generated by OpenRuntimes)
host    replication     ${REPLICATION_USER}    ${REPLICATION_ALLOWED_NETWORKS}    scram-sha-256
`;

    try {
      if (fs.existsSync(hbaPath)) {
        const hbaContent = fs.readFileSync(hbaPath, 'utf8');
        if (!hbaContent.includes('host    replication')) {
          fs.appendFileSync(hbaPath, replicationEntry);
          console.log("Added replication entries to pg_hba.conf");
        }
      }
    } catch (err) {
      console.error(`Failed to update pg_hba.conf: ${err.message}`);
    }
  }
}

// Create replication user on primary
async function createReplicationUser() {
  if (REPLICATION_MODE !== 'primary' || !REPLICATION_PASSWORD) {
    return;
  }

  console.log("Creating replication user...");

  let retries = 10;
  while (retries > 0) {
    try {
      const client = new Client({
        host: "localhost",
        port: 5432,
        user: process.env.POSTGRES_USER,
        password: process.env.POSTGRES_PASSWORD,
        database: process.env.POSTGRES_DB,
      });

      await client.connect();

      // Check if user exists
      const userCheck = await client.query(
        "SELECT 1 FROM pg_roles WHERE rolname = $1",
        [REPLICATION_USER]
      );

      if (userCheck.rows.length === 0) {
        // Create replication user
        await client.query(`CREATE USER ${REPLICATION_USER} WITH REPLICATION ENCRYPTED PASSWORD '${REPLICATION_PASSWORD}'`);
        console.log(`Replication user '${REPLICATION_USER}' created successfully`);
      } else {
        // Update password
        await client.query(`ALTER USER ${REPLICATION_USER} WITH PASSWORD '${REPLICATION_PASSWORD}'`);
        console.log(`Replication user '${REPLICATION_USER}' password updated`);
      }

      // Create replication slot if it doesn't exist
      const slotCheck = await client.query(
        "SELECT 1 FROM pg_replication_slots WHERE slot_name = $1",
        [REPLICATION_SLOT_NAME]
      );

      if (slotCheck.rows.length === 0) {
        await client.query(`SELECT pg_create_physical_replication_slot('${REPLICATION_SLOT_NAME}')`);
        console.log(`Replication slot '${REPLICATION_SLOT_NAME}' created`);
      }

      await client.end();
      return;
    } catch (err) {
      console.error(`Failed to create replication user (retries left: ${retries}):`, err.message);
      retries--;
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
  }
}

// Configure replica to connect to primary using pg_basebackup
async function configureReplica() {
  if (REPLICATION_MODE !== 'replica' || !PRIMARY_HOST || !REPLICATION_PASSWORD) {
    console.log("Skipping replica configuration - missing required parameters");
    return;
  }

  const standbySignal = path.join(PGDATA, 'standby.signal');
  const pgAutoConf = path.join(PGDATA, 'postgresql.auto.conf');

  // Check if already configured as replica
  if (fs.existsSync(standbySignal)) {
    console.log("Already configured as replica (standby.signal exists)");
    return;
  }

  // Check if data directory is empty (fresh replica)
  const dataFiles = fs.readdirSync(PGDATA);
  const hasData = dataFiles.length > 0 && !dataFiles.every(f => f.startsWith('.'));

  if (!hasData) {
    console.log("Empty data directory - performing base backup from primary...");

    try {
      // Perform base backup
      const pgPassFile = '/tmp/.pgpass';
      fs.writeFileSync(pgPassFile, `${PRIMARY_HOST}:${PRIMARY_PORT}:*:${REPLICATION_USER}:${REPLICATION_PASSWORD}\n`);
      fs.chmodSync(pgPassFile, 0o600);

      execSync(`pg_basebackup -h ${PRIMARY_HOST} -p ${PRIMARY_PORT} -U ${REPLICATION_USER} -D ${PGDATA} -Fp -Xs -P -R -S ${REPLICATION_SLOT_NAME}`, {
        env: { ...process.env, PGPASSFILE: pgPassFile },
        stdio: 'inherit'
      });

      fs.unlinkSync(pgPassFile);
      console.log("Base backup completed successfully");
    } catch (err) {
      console.error(`Base backup failed: ${err.message}`);
      // Continue anyway - we'll try to configure manually
    }
  }

  // Create standby.signal file
  fs.writeFileSync(standbySignal, '');
  console.log("Created standby.signal file");

  // Configure primary connection info
  let primaryConnInfo = `host=${PRIMARY_HOST} port=${PRIMARY_PORT} user=${REPLICATION_USER} password=${REPLICATION_PASSWORD}`;
  if (PRIMARY_CONNINFO_EXTRA) {
    primaryConnInfo += ` ${PRIMARY_CONNINFO_EXTRA}`;
  }

  let autoConf = `
# Replica configuration (generated by OpenRuntimes)
primary_conninfo = '${primaryConnInfo}'
primary_slot_name = '${REPLICATION_SLOT_NAME}'
recovery_target_timeline = '${RECOVERY_TARGET_TIMELINE}'
`;

  if (RESTORE_COMMAND) {
    autoConf += `restore_command = '${RESTORE_COMMAND}'\n`;
  }

  try {
    // Append to postgresql.auto.conf
    if (fs.existsSync(pgAutoConf)) {
      const existingConf = fs.readFileSync(pgAutoConf, 'utf8');
      if (!existingConf.includes('primary_conninfo')) {
        fs.appendFileSync(pgAutoConf, autoConf);
      }
    } else {
      fs.writeFileSync(pgAutoConf, autoConf);
    }
    console.log("Replica configuration written to postgresql.auto.conf");
  } catch (err) {
    console.error(`Failed to write replica config: ${err.message}`);
  }
}

function startPostgres() {
  console.log("Starting PostgreSQL server...");

  // For replica mode, configure before starting
  if (REPLICATION_MODE === 'replica') {
    try {
      configureReplica();
    } catch (err) {
      console.error("Failed to configure replica:", err.message);
    }
  }

  postgresProcess = spawn("docker-entrypoint.sh", ["postgres"], {
    env: {
      ...process.env,
    },
  });

  let configApplied = false;

  postgresProcess.stdout.on("data", (data) => {
    const message = data.toString();
    console.log(`[PostgreSQL] ${message}`);

    if (message.includes("database system is ready to accept connections")) {
      if (!dbReady) {
        dbReady = true;
        console.log("PostgreSQL is ready to accept connections");

        // Write startup timing if provided
        if (process.env.STARTUP_TIME && !startupTimingWritten) {
          const start = parseFloat(process.env.STARTUP_TIME);
          const end = parseFloat(fs.readFileSync('/proc/uptime', 'utf8').split(' ')[0]);
          const elapsed = (end - start).toFixed(3);
          fs.appendFileSync('/mnt/telemetry/timings.txt', `startup=${elapsed}\n`);
          startupTimingWritten = true;
          console.log(`Recorded startup timing: ${elapsed}s`);
        }

        // Configure replication after PostgreSQL is ready
        setTimeout(async () => {
          if (!configApplied && REPLICATION_MODE !== 'standalone') {
            configApplied = true;
            generateReplicationConfig();

            if (REPLICATION_MODE === 'primary') {
              await createReplicationUser();
            }
          }
          connectHealthClient();
        }, 2000);
      }
    }
  });

  postgresProcess.stderr.on("data", (data) => {
    const message = data.toString();
    console.error(`[PostgreSQL] ${message}`);

    // PostgreSQL logs "ready to accept connections" to stderr
    if (message.includes("database system is ready to accept connections") ||
        message.includes("entering standby mode") ||
        message.includes("started streaming WAL")) {
      if (!dbReady) {
        dbReady = true;
        console.log("PostgreSQL is ready");

        // Write startup timing if provided
        if (process.env.STARTUP_TIME && !startupTimingWritten) {
          const start = parseFloat(process.env.STARTUP_TIME);
          const end = parseFloat(fs.readFileSync('/proc/uptime', 'utf8').split(' ')[0]);
          const elapsed = (end - start).toFixed(3);
          fs.appendFileSync('/mnt/telemetry/timings.txt', `startup=${elapsed}\n`);
          startupTimingWritten = true;
          console.log(`Recorded startup timing: ${elapsed}s`);
        }

        // Configure replication after PostgreSQL is ready
        setTimeout(async () => {
          if (!configApplied && REPLICATION_MODE !== 'standalone') {
            configApplied = true;
            generateReplicationConfig();

            if (REPLICATION_MODE === 'primary') {
              await createReplicationUser();
            }
          }
          connectHealthClient();
        }, 2000);
      }
    }
  });

  postgresProcess.on("close", (code) => {
    console.log(`PostgreSQL process exited with code ${code}`);
    dbReady = false;
  });
}

function connectHealthClient() {
  pgClient = new Client({
    host: "localhost",
    port: 5432,
    user: process.env.POSTGRES_USER,
    password: process.env.POSTGRES_PASSWORD,
    database: process.env.POSTGRES_DB,
  });

  pgClient.connect((err) => {
    if (err) {
      console.error("Failed to connect health check client:", err);
      pgClient = null;
      setTimeout(connectHealthClient, 5000);
    } else {
      console.log("Health check client connected");
    }
  });
}

// Get replication status
async function getReplicationStatus() {
  if (!pgClient || REPLICATION_MODE === 'standalone') {
    return null;
  }

  try {
    if (REPLICATION_MODE === 'primary') {
      // Get primary status
      const walStatus = await pgClient.query('SELECT pg_current_wal_lsn() as current_lsn');

      // Get connected standbys
      const standbys = await pgClient.query(`
        SELECT
          client_addr,
          client_hostname,
          client_port,
          state,
          sent_lsn,
          write_lsn,
          flush_lsn,
          replay_lsn,
          sync_state,
          sync_priority,
          reply_time
        FROM pg_stat_replication
      `);

      // Get replication slots
      const slots = await pgClient.query(`
        SELECT
          slot_name,
          plugin,
          slot_type,
          datoid,
          database,
          active,
          active_pid,
          restart_lsn,
          confirmed_flush_lsn
        FROM pg_replication_slots
      `);

      return {
        role: 'primary',
        currentLsn: walStatus.rows[0]?.current_lsn || null,
        connectedStandbys: standbys.rows.length,
        standbys: standbys.rows.map(s => ({
          clientAddr: s.client_addr,
          clientHostname: s.client_hostname,
          clientPort: s.client_port,
          state: s.state,
          sentLsn: s.sent_lsn,
          writeLsn: s.write_lsn,
          flushLsn: s.flush_lsn,
          replayLsn: s.replay_lsn,
          syncState: s.sync_state,
          syncPriority: s.sync_priority,
          replyTime: s.reply_time
        })),
        replicationSlots: slots.rows.map(s => ({
          slotName: s.slot_name,
          slotType: s.slot_type,
          database: s.database,
          active: s.active,
          activePid: s.active_pid,
          restartLsn: s.restart_lsn
        }))
      };
    } else if (REPLICATION_MODE === 'replica') {
      // Get replica status
      const isInRecovery = await pgClient.query('SELECT pg_is_in_recovery() as in_recovery');

      if (!isInRecovery.rows[0]?.in_recovery) {
        return { role: 'replica', inRecovery: false, error: 'Not in recovery mode' };
      }

      const walStatus = await pgClient.query(`
        SELECT
          pg_last_wal_receive_lsn() as receive_lsn,
          pg_last_wal_replay_lsn() as replay_lsn,
          pg_last_xact_replay_timestamp() as last_replay_timestamp
      `);

      // Calculate replication lag
      let lagSeconds = null;
      try {
        const lagQuery = await pgClient.query(`
          SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) as lag_seconds
        `);
        lagSeconds = parseFloat(lagQuery.rows[0]?.lag_seconds) || null;
      } catch (e) {
        // Lag calculation may fail if no transactions have been replayed
      }

      // Get WAL receiver status
      let walReceiver = null;
      try {
        const walReceiverQuery = await pgClient.query(`
          SELECT
            pid,
            status,
            receive_start_lsn,
            receive_start_tli,
            received_lsn,
            received_tli,
            last_msg_send_time,
            last_msg_receipt_time,
            sender_host,
            sender_port,
            conninfo
          FROM pg_stat_wal_receiver
        `);
        if (walReceiverQuery.rows.length > 0) {
          const wr = walReceiverQuery.rows[0];
          walReceiver = {
            pid: wr.pid,
            status: wr.status,
            receivedLsn: wr.received_lsn,
            lastMsgSendTime: wr.last_msg_send_time,
            lastMsgReceiptTime: wr.last_msg_receipt_time,
            senderHost: wr.sender_host,
            senderPort: wr.sender_port
          };
        }
      } catch (e) {
        // WAL receiver stats may not be available
      }

      return {
        role: 'replica',
        inRecovery: true,
        receiveLsn: walStatus.rows[0]?.receive_lsn || null,
        replayLsn: walStatus.rows[0]?.replay_lsn || null,
        lastReplayTimestamp: walStatus.rows[0]?.last_replay_timestamp || null,
        lagSeconds: lagSeconds,
        walReceiver: walReceiver
      };
    }
  } catch (err) {
    console.error("Failed to get replication status:", err.message);
    return { error: err.message };
  }
}

app.get("/__opr/health", async (req, res) => {
  if (!dbReady) {
    return res.status(503).send("PostgreSQL is starting");
  }

  try {
    await pgClient.query("SELECT 1");
    res.status(200).send("OK");
  } catch (err) {
    console.error("Health check failed:", err);
    res.status(503).send("Database unavailable");
  }
});

app.get("/__opr/timings", (req, res) => {
  try {
    const timings = fs.readFileSync("/mnt/telemetry/timings.txt", { encoding: "utf8" });
    res.setHeader("content-type", "text/plain; charset=utf-8");
    res.status(200).send(timings);
  } catch (err) {
    res.status(200).send("startup=0");
  }
});

app.get("/__opr/status", async (req, res) => {
  let volumeInfo = {};
  let currentConnections = 0;

  // Get connection count
  if (pgClient && dbReady) {
    try {
      const connResult = await pgClient.query("SELECT count(*) as count FROM pg_stat_activity WHERE state != 'idle'");
      currentConnections = parseInt(connResult.rows[0]?.count || 0);
    } catch (err) {
      console.error("Failed to get connection count:", err.message);
    }
  }

  // Check volume status
  try {
    const pgDataPath = process.env.PGDATA || "/var/lib/postgresql/data";
    if (fs.existsSync(pgDataPath)) {
      const dfOutput = execSync(`df -h "${pgDataPath}" 2>/dev/null || echo ""`).toString();
      const lines = dfOutput.trim().split('\n');
      if (lines.length > 1) {
        const parts = lines[1].split(/\s+/);
        if (parts.length >= 5) {
          volumeInfo.data = {
            path: pgDataPath,
            size: parts[1],
            used: parts[2],
            available: parts[3],
            usePercent: parts[4],
            mounted: true
          };
        }
      }
    } else {
      volumeInfo.data = { path: pgDataPath, mounted: false };
    }

    // Check backup directory
    if (fs.existsSync("/mnt/backups")) {
      const dfOutput = execSync("df -h /mnt/backups 2>/dev/null || echo ''").toString();
      const lines = dfOutput.trim().split('\n');
      if (lines.length > 1) {
        const parts = lines[1].split(/\s+/);
        if (parts.length >= 5) {
          volumeInfo.backups = {
            path: "/mnt/backups",
            size: parts[1],
            used: parts[2],
            available: parts[3],
            usePercent: parts[4],
            mounted: true
          };
        }
      }
    } else {
      volumeInfo.backups = { path: "/mnt/backups", mounted: false };
    }
  } catch (err) {
    // Volume info is optional, don't fail the status endpoint
    console.error("Failed to get volume info:", err.message);
  }

  const replicationStatus = await getReplicationStatus();

  const status = {
    ready: dbReady,
    engine: "postgres",
    version: "16",
    uptime: process.uptime(),
    connections: {
      current: currentConnections,
      max: parseInt(process.env.POSTGRES_MAX_CONNECTIONS || "100"),
    },
    volumes: volumeInfo,
    replication: replicationStatus || {
      mode: REPLICATION_MODE
    }
  };

  res.json(status);
});

// Replication-specific endpoints
app.get("/__opr/replication", async (req, res) => {
  const status = await getReplicationStatus();
  if (!status) {
    return res.json({ mode: 'standalone', enabled: false });
  }
  res.json({
    mode: REPLICATION_MODE,
    enabled: REPLICATION_MODE !== 'standalone',
    walLevel: WAL_LEVEL,
    maxWalSenders: MAX_WAL_SENDERS,
    maxReplicationSlots: MAX_REPLICATION_SLOTS,
    ...status
  });
});

app.post("/__opr/replication/promote", async (req, res) => {
  if (REPLICATION_MODE !== 'replica') {
    return res.status(400).json({ error: 'Only available on replica' });
  }

  try {
    // Check if in recovery mode
    const recoveryCheck = await pgClient.query('SELECT pg_is_in_recovery() as in_recovery');
    if (!recoveryCheck.rows[0]?.in_recovery) {
      return res.status(400).json({ error: 'Server is not in recovery mode' });
    }

    // Promote to primary
    await pgClient.query('SELECT pg_promote()');
    res.json({ success: true, message: 'Promotion initiated. Server will become primary.' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post("/__opr/replication/pause", async (req, res) => {
  if (REPLICATION_MODE !== 'replica') {
    return res.status(400).json({ error: 'Only available on replica' });
  }

  try {
    await pgClient.query('SELECT pg_wal_replay_pause()');
    res.json({ success: true, message: 'WAL replay paused' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post("/__opr/replication/resume", async (req, res) => {
  if (REPLICATION_MODE !== 'replica') {
    return res.status(400).json({ error: 'Only available on replica' });
  }

  try {
    await pgClient.query('SELECT pg_wal_replay_resume()');
    res.json({ success: true, message: 'WAL replay resumed' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create new replication slot (primary only)
app.post("/__opr/replication/slot/:name", async (req, res) => {
  if (REPLICATION_MODE !== 'primary') {
    return res.status(400).json({ error: 'Only available on primary' });
  }

  const slotName = req.params.name;
  if (!slotName || !/^[a-z0-9_]+$/.test(slotName)) {
    return res.status(400).json({ error: 'Invalid slot name (use lowercase letters, numbers, underscores)' });
  }

  try {
    await pgClient.query(`SELECT pg_create_physical_replication_slot($1)`, [slotName]);
    res.json({ success: true, message: `Replication slot '${slotName}' created` });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Drop replication slot (primary only)
app.delete("/__opr/replication/slot/:name", async (req, res) => {
  if (REPLICATION_MODE !== 'primary') {
    return res.status(400).json({ error: 'Only available on primary' });
  }

  const slotName = req.params.name;

  try {
    await pgClient.query(`SELECT pg_drop_replication_slot($1)`, [slotName]);
    res.json({ success: true, message: `Replication slot '${slotName}' dropped` });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

process.on("SIGTERM", () => {
  console.log("Received SIGTERM, shutting down gracefully...");

  if (postgresProcess) {
    postgresProcess.kill("SIGTERM");
  }

  if (pgClient) {
    pgClient.end().then(() => {
      console.log("Shutdown complete");
      process.exit(0);
    }).catch(() => {
      process.exit(0);
    });
  } else {
    process.exit(0);
  }
});

process.on("SIGINT", () => {
  console.log("Received SIGINT, shutting down gracefully...");

  if (postgresProcess) {
    postgresProcess.kill("SIGINT");
  }

  if (pgClient) {
    pgClient.end().then(() => {
      console.log("Shutdown complete");
      process.exit(0);
    }).catch(() => {
      process.exit(0);
    });
  } else {
    process.exit(0);
  }
});

app.listen(MANAGEMENT_PORT, "0.0.0.0", () => {
  console.log(`OpenRuntimes management server listening on port ${MANAGEMENT_PORT}`);
  startPostgres();
});
